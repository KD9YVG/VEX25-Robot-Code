{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_1 = Controller(PRIMARY)\nLeft = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nRight = Motor(Ports.PORT2, GearSetting.RATIO_18_1, True)\nChain = Motor(Ports.PORT3, GearSetting.RATIO_18_1, False)\nString = Motor(Ports.PORT4, GearSetting.RATIO_18_1, False)\nFinger = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\nfrom math import pi\n\n# Start constants\n\n# Define axis3, the left stick up/down,\n# as the stick to drive forward and backwards.\nAXIS_DRIVE_FORWARD_AND_BACKWARD=controller_1.axis3\n\n# Define axis1, the right stick left/right,\n# as the stick to turn the robot.\nAXIS_TURN_LEFT_AND_RIGHT=controller_1.axis1\n\n# Set the deadzone for the controller,\n# so that if any analog input is less than the deadzone,\n# it is ignored.\nDEADZONE=10\n\n# Define the buttons to control the chain.\n# All of the controls are grouped so that\n# it is easier to visualize and modify.\nBUTTON_CHAIN_FORWARD=controller_1.buttonL1\nBUTTON_CHAIN_REVERSE=controller_1.buttonL2\nBUTTON_STRING_FORWARD=controller_1.buttonR1\nBUTTON_STRING_REVERSE=controller_1.buttonR2\n\n# Buttons for finger movements\nBUTTON_FINGER=controller_1.buttonX\n\n# Define the speed multipliers. These should\n# be values between 0 and 1.\n\n# Speed multiplier of the whole drivetrain,\n# usually should not change.\nNUMBER_OVERALL_SPEED=1\n\n# Multiplier for forward and backward\nNUMBER_DRIVE_SPEED=0.85\n\n# Multiplier for turning\nNUMBER_TURN_SPEED=0.4\n\n# Speed to move the string at\nNUMBER_STRING_SPEED=0.1\nNUMBER_STRING_HARDSTOP=0\n# IMPORTANT NOTE: The string and chain\n# use digital inputs, so the string\n# is not able to move faster or slower\n# than this speed.\n\n# Set this to 0.15 if you need to adjust\n# the hardstop.\n\n# Speed to move the chain at. See the note\n# above about digital inputs.\nNUMBER_CHAIN_SPEED=1\n\nSINGLE_DEGREE=1597208273\n\n#endregion constants\n\n# Variable to check whether the timer is currently runnning\nisgoing = False\nisfingerdown = True\n\ndef turn_degrees(d,wait=False):\n    Right.set_position(0,TURNS)\n    Left.set_position(0,TURNS)\n    Right.spin_to_position((SINGLE_DEGREE*d)/200000000000,TURNS,wait=False)\n    Left.spin_to_position(0-(SINGLE_DEGREE*d)/200000000000,TURNS,wait=wait)\n\ndef move_forward(inches,wait=False):\n    Right.set_position(0,TURNS)\n    Left.set_position(0,TURNS)\n    Right.spin_to_position(0-(inches+1)/(4*pi),TURNS,wait=False)\n    Left.spin_to_position(0-(inches+1)/(4*pi),TURNS,wait=wait)\ndef fun():\n    Chain.set_velocity(75,PERCENT)\n    Chain.spin(REVERSE)\n    move_forward(80,True)\n    wait(10, SECONDS)\n    Chain.stop()\n#fun()\ndef autonomous_old():\n    Chain.set_velocity(100,PERCENT)\n    Chain.spin(REVERSE)\n    move_forward(10,True)\n    wait(10, SECONDS)\n    # turn_degrees(-90,True)\n\ndef autonomous():\n    move_forward(-36,True)\n    fingercallback()\n    Chain.set_velocity(100,PERCENT)\n    Chain.spin(REVERSE)\n    wait(1, SECONDS)\n    Chain.spin(FORWARD)\n    wait(1,SECONDS)\n    Chain.stop()\n    fingercallback()\n    move_forward(20, True)\n    turn_degrees(-90, True)\n    move_forward(-30,True)\n\ndef deadzonify(inputvalue):\n    # Make the input zero if the absolute value\n    # is less than the deadzone.\n\n    # Check the absolute value, so that small\n    # NEGATIVE values are also ignored\n    if abs(inputvalue)<DEADZONE:\n        # If it's less than the deadzone, make it zero.\n        return 0\n    # Otherwise, don't change it.\n    return inputvalue\n\ndef fingercallback():\n    global isfingerdown\n    isfingerdown=not isfingerdown\n    Finger.set_velocity(100, PERCENT)\n    if isfingerdown:\n        Finger.spin_to_position(0, TURNS,wait=True)\n        ## Finger.set_velocity(0.0001,PERCENT)\n        ## Finger.spin(FORWARD)\n    else:\n        Finger.stop()\n        Finger.spin_to_position(-0.2,TURNS,wait=True)\nfingercallback()\n\nautonomous()\n#COCKROACH WAS HERE\n\ndef when_started():\n    # Clear the screen and tell the user\n    # how to start the timer.\n    controller_1.screen.clear_screen()\n    controller_1.screen.set_cursor(1,1)\n    controller_1.screen.print(\"Hold B for timer\")\n    # Add callbacks for each button and axis\n    BUTTON_CHAIN_FORWARD.pressed(lambda: Chain.spin(FORWARD))\n    BUTTON_CHAIN_FORWARD.released(Chain.stop)\n    BUTTON_CHAIN_REVERSE.pressed(lambda: Chain.spin(REVERSE))\n    BUTTON_CHAIN_REVERSE.released(Chain.stop)\n    BUTTON_STRING_FORWARD.pressed(lambda: String.spin(FORWARD))\n    BUTTON_STRING_FORWARD.released(String.stop)\n    BUTTON_STRING_REVERSE.pressed(lambda: String.spin(REVERSE))\n    BUTTON_STRING_REVERSE.released(String.stop)\n    ##BUTTON_FINGER_DOWN.pressed(lambda: Finger.spin(REVERSE))\n    ##BUTTON_FINGER_DOWN.released(Finger.stop)\n    ##BUTTON_FINGER_UP.pressed(lambda: Finger.spin(FORWARD))\n    ##BUTTON_FINGER_UP.released(Finger.stop)\n    BUTTON_FINGER.released(fingercallback)\n    AXIS_DRIVE_FORWARD_AND_BACKWARD.changed(setaxis)\n    AXIS_TURN_LEFT_AND_RIGHT.changed(setaxis)\n    # I really should make buttonB a constant, like BUTTON_TIMER\n    # or something. And make the callbacks \"timerpressed\" instead\n    # of \"Apressed\"\n    controller_1.buttonB.released(Areleased)\n    controller_1.buttonB.pressed(Apressed)\n    # Make the chain and string go the speed we've defined\n    Chain.set_velocity(NUMBER_CHAIN_SPEED*100,PERCENT) \n    String.set_velocity(NUMBER_STRING_SPEED*100,PERCENT)\n    # Set left motor and right motor to zero, because of the note below.\n    Left.set_velocity(0,PERCENT)\n    Right.set_velocity(0,PERCENT)\n    # When the left and right motors\n    # are moving, we need to set_velocity to\n    # the controller's input percentage.\n    # When the controller is moved, the velocity\n    # is changed. The easiest way to do this\n    # is to make it always \"on\", just at 0%.\n    Left.spin(REVERSE)\n    Right.spin(FORWARD)\n    # Finger should brake when not being moved.\n    Finger.set_stopping(BRAKE)\n    while True:\n        ## print(Finger.position(TURNS))\n        ## print(String.position(DEGREES)) # Debugging to figure out the hardstop for the string\n\n        # If the string is below the hardstop, move it there, but, not if left is pressed.\n        if String.position(DEGREES)<NUMBER_STRING_HARDSTOP and not controller_1.buttonLeft.pressing():\n            String.spin_to_position(NUMBER_STRING_HARDSTOP+4,DEGREES,wait=False)\n            print(\"Hardstop triggered\")\n\n        ## print(brain.timer.time(SECONDS)) # Debugging from the old timer\n        if isgoing: # While the timer is running, display the timer value on the screen.\n            controller_1.screen.clear_row(1)\n            controller_1.screen.set_cursor(2,1)\n            controller_1.screen.print(brain.timer.time(SECONDS))\n        wait(15,MSEC) # Make sure the event loop doesn't get bogged down.\n\ndef setaxis(): # Callback when any axis is changed\n    drive_speed_multiplier=(NUMBER_OVERALL_SPEED*NUMBER_DRIVE_SPEED) # includes drive multiplier AND overall mult\n    axis_position=deadzonify(AXIS_DRIVE_FORWARD_AND_BACKWARD.position()) # Position of the axis, taking deadzone into account\n    updownpos=drive_speed_multiplier*(0-axis_position) # Make the axis inverted, to fix an inverted driving issue we had\n\n    turn_speed_multiplier=(NUMBER_OVERALL_SPEED*NUMBER_TURN_SPEED) # includes turn multiplier AND overall mult\n    axis_position=deadzonify(AXIS_TURN_LEFT_AND_RIGHT.position()) # Position of the axis, taking deadzone into account\n    leftrightpos=turn_speed_multiplier*axis_position               # Do the final computations, as above.\n\n    Left.set_velocity(updownpos+leftrightpos,PERCENT)              # Make the motors actually do the positions.\n    Right.set_velocity(updownpos-leftrightpos,PERCENT)\n\njustchangedisgoing=False # Make sure the timer isn't started on press, and stopped on the same release.\n\ndef Apressed(): # Callback when timer button pressed\n    global isgoing,justchangedisgoing\n    if isgoing:\n        isgoing=False\n        justchangedisgoing=True            #Get ready and show how to time\n        controller_1.screen.clear_screen()\n        controller_1.screen.set_cursor(2,1)\n        controller_1.screen.print(str(brain.timer.time(SECONDS)))\n        controller_1.screen.set_cursor(1,1)\n        controller_1.screen.print(\"Hold B for timer\")\n    else:\n        controller_1.screen.clear_screen()    # Display message showing how to start\n        controller_1.screen.set_cursor(1,1)\n        controller_1.screen.print(\"Let go of B to start!\")\n\ndef Areleased(): # Callback when timer button released\n    global isgoing,justchangedisgoing\n    if not isgoing:\n        if justchangedisgoing:\n            justchangedisgoing=False\n        else:\n            brain.timer.clear()                       # Clear timer, and inform user how to stop.\n            controller_1.screen.set_cursor(1,1)\n            controller_1.screen.print(\"Press B to stop\")\n            isgoing=True\n\nChain.set_stopping(HOLD)  # Make intake hold its position when stopped\nString.set_stopping(HOLD)\n\nwait(15,MSEC)\n\ncompetition = Competition(when_started, autonomous) # Define the competition for VEX to do whatever with","textLanguage":"python","robotConfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[1],"name":"Left","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[2],"name":"Right","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[3],"name":"Chain","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[4],"name":"String","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[5],"name":"Finger","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}